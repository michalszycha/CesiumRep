<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Use correct character set. -->
  <meta charset="utf-8">
  <!-- Tell IE to use the latest, best version. -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <title>Hello World!</title>
  <script src="../Build/Cesium/Cesium.js"></script>
  <script src="../GlobalPosition.js" ></script>
  <script src="../Angle.js" ></script>
  <script src="../Ellipsoid.js" ></script>
  <script src="../GeodeticCalculator.js" ></script>
  <script src="../GeodeticCurve.js" ></script>
  <script src="../GeodeticMeasurement.js" ></script>
  <script src="../GlobalCoordinates.js" ></script>
  <style>
      @import url(../Build/Cesium/Widgets/widgets.css);
      html, body, #cesiumContainer {
          width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
      }
  </style>
</head>
<body>
  <div id="cesiumContainer">

    <div id="buttonContainer" style="position:absolute;left:2px;top:2px;
z-index:1;">
<button onclick="obserwuj_samolot()" class="cesiumbutton">
Obserwuj samolot</button>
</div>

<div id="buttonContainer" style="position:absolute; left:2px; top:25px;
z-index:1;">
<button onclick="patrz_z_gory()" class="cesiumbutton">
Patrz z góry</button>
</div>

</div>

  <script>

  //Definicja klasy wspolrzednych pasow startowych
  class PasyStartowe {
    constructor(start_lat, start_long, koniec_lat, koniec_long){
      this.start_lat = start_lat;
      this.start_long = start_long;
      this.koniec_lat = koniec_lat;
      this.koniec_long = koniec_long;
    }
  }
  //Stworzenie obiektów konkretnych pasów startowych
  gdansk_pas1 = new PasyStartowe(54.380887, 18.452738, 54.371910, 18.489267);
  warszawa_pas1 = new PasyStartowe(52.155907, 20.975687, 52.177143, 20.957177);


  //Definicja klasy lotow z Gdanska do Warszawy
  class GdnToWaw {
    constructor(wylot, przylot, numer_lotu) {
      this.wylot = wylot;
      this.przylot = przylot;
      this.numer_lotu = numer_lotu;
    }
  }

  //Stworzenie obiektow konkretnych lotow klasy Gdansk - Warszawa
  gdnwaw1 = new GdnToWaw(31500,35100,'LO3832'); //8:45 - 09:45
  gdnwaw2 = new GdnToWaw(43500,47100,'LO3836'); //12:05 - 13:05
  gdnwaw3 = new GdnToWaw(65400,69300,'LO3816'); //18:10 - 19:15


  //Definicja klasy lotow z Warszawy do Gdanska
  class WawToGdn {
    constructor(wylot, przylot, numer_lotu) {
      this.wylot = wylot;
      this.przylot = przylot;
      this.numer_lotu = numer_lotu;
    }
  }

  //Stworzenie obiektow konkretnych lotow klasy Warszawa - Gdansk
  wawgdn1 = new WawToGdn(26100,29700,'LO3831'); //7:15 - 08:15
  wawgdn2 = new WawToGdn(48000,51300,'LO3937'); //13:20 - 14:15
  wawgdn3 = new WawToGdn(70800,74100,'LO3825'); //19:40 - 20:35

  function obserwuj_samolot() {
    viewer.trackedEntity = entity;
  }

  function patrz_z_gory() {
    viewer.trackedEntity = undefined;
    viewer.zoomTo(viewer.entities, new Cesium.HeadingPitchRange(0, Cesium.Math.toRadians(-90)));
  }

  //definicja funkcji zwracającej sciezke lotu samolotu z Gdanska do Warszawy
  //przekazywane parametry to wlasciwosci obiektow klasy GdnToWaw (wylot,przylot)
  function generuj_trase_GDN_WAW(czas_start,czas_stop){
    //definicja zmiennej przechowujacej wspolrzedne i czas
    var property = new Cesium.SampledPositionProperty();
    //definicja czasu jako poczatek lotu
    var time = Cesium.JulianDate.fromDate(new Date(2019, 10, 11));

    //dodanie punktu poczatkowego na pasie w Gdansku
    time = Cesium.JulianDate.addSeconds(time, czas_start, new Cesium.JulianDate());
    var position = Cesium.Cartesian3.fromDegrees(gdansk_pas1.start_long, gdansk_pas1.start_lat, 170.0);
    property.addSample(time, position);

    //dodanie punktu na koncu pasa w Gdansku (60s pozniej)
    time = Cesium.JulianDate.addSeconds(time, 60, new Cesium.JulianDate());
    position = Cesium.Cartesian3.fromDegrees(gdansk_pas1.koniec_long, gdansk_pas1.koniec_lat, 180.0);
    property.addSample(time, position);

    //pozostaly czas na animacje lotu minus 2*60s na start i lądowanie
    var reszta_czasu = czas_stop - czas_start - 120;
    var krok_czasu = reszta_czasu / 5; //5 kroków (punktow)

    //dodanie punktow dla pozostałego czasu pomiedzy startem i lądowaniem
    for (var i = 1; i <= 4; i += 1) {
        time = Cesium.JulianDate.addSeconds(time, i * krok_czasu, new Cesium.JulianDate());
        position = Cesium.Cartesian3.fromDegrees(gdansk_pas1.koniec_long + (0.49 * i), gdansk_pas1.koniec_lat - (0.44 * i), ((5 % i)+1) * 11000.0);
        property.addSample(time, position);
    }

    //dodanie punktu na końcu pasa w Warszawie (10s pozniej - trafienie w pas)
    time = Cesium.JulianDate.addSeconds(time, 10, new Cesium.JulianDate());
    position = Cesium.Cartesian3.fromDegrees(warszawa_pas1.koniec_long, warszawa_pas1.koniec_lat, 140.0);
    property.addSample(time, position);

    //dodanie punktu na poczatku pasa w Warszawie (60s pozniej)
    time = Cesium.JulianDate.addSeconds(time, 60, new Cesium.JulianDate());
    position = Cesium.Cartesian3.fromDegrees(warszawa_pas1.start_long, warszawa_pas1.start_lat, 140.0);
    property.addSample(time, position);


  return property
  }


  var viewer = new Cesium.Viewer('cesiumContainer', {
    infoBox: false, //Disable InfoBox widget
    selectionIndicator: false, //Disable selection indicator
    shouldAnimate: true, // Enable animations
    terrainProvider: Cesium.createWorldTerrain()
	});

	//Enable lighting based on sun/moon positions
	viewer.scene.globe.enableLighting = true;

	//Enable depth testing so things behind the terrain disappear.
	viewer.scene.globe.depthTestAgainstTerrain = true;

	//Set the random number seed for consistent results.
	Cesium.Math.setRandomNumberSeed(3);

	//Set bounds of our simulation time
	var duration = 720;
	var start = Cesium.JulianDate.fromDate(new Date(2019, 10, 11, 7));
	var stop = Cesium.JulianDate.addSeconds(start, 86400, new Cesium.JulianDate());

	// 8:45 -> 31500s od 00:00
	var startLot1 = Cesium.JulianDate.addSeconds(start, 31500, new Cesium.JulianDate());
	// 9:45 -> 35100s od 00:00
	var stopLot1 = Cesium.JulianDate.addSeconds(start, 35100, new Cesium.JulianDate());
	var duration2 = Cesium.JulianDate.secondsDifference(stopLot1,startLot1);
	console.info('dur',duration2);
	//Make sure viewer is at the desired time.
	viewer.clock.startTime = start.clone();
	viewer.clock.stopTime = stop.clone();
	viewer.clock.currentTime = start.clone();
	viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP; //Loop at the end
	viewer.clock.multiplier = 10;

	//Set timeline to simulation bounds
	viewer.timeline.zoomTo(start, stop);

	//Generate a random circular pattern with varying heights.
	//function computeCirclularFlight(lon, lat, radius) {
	function computeCirclularFlight(lon1, lat1, lon2, lat2) {
		var property = new Cesium.SampledPositionProperty();

		//funkcje z biblioteki GeodesyLibrary
		// instantiate the calculator
		var geoCalc = new GeodeticCalculator();

		// select a reference elllipsoid
		var reference = Ellipsoid.WGS84;

		// set Pike's Peak position
		var pointStart = new GlobalPosition(lat1, lon1, 50.0);

		// set Alcatraz Island coordinates
		var pointStop = new GlobalPosition(lat2, lon2, 47.0);

		// calculate the geodetic measurement
		var geoMeasurement = geoCalc.calculateGeodeticMeasurement(reference, pointStart, pointStop);

		var lonTmp = lon1;
		var latTmp = lat1;
		var i = 0.20
		var x = latTmp-lat2
		var y = parseInt(x/i);
		var t = parseInt(duration2/y);
		console.info('t',t);
		var z = 0;
		var dontReachLat = 1;
		var dontReachLon = 1;
		console.info('bool',Boolean(dontReachLat));
		while(latTmp>lat2) {
			var time = Cesium.JulianDate.addSeconds(startLot1, z, new Cesium.JulianDate());
			console.info('time',time);
			var position = Cesium.Cartesian3.fromDegrees(lonTmp, latTmp, 3000);
			property.addSample(time, position);

			//Also create a point for each sample we generate.
			viewer.entities.add({
				position : position,
				point : {
					pixelSize : 8,
					color : Cesium.Color.TRANSPARENT,
					outlineColor : Cesium.Color.YELLOW,
					outlineWidth : 3
				}
			});
			z+=t;
			latTmp-=i;
			lonTmp+=i;
		}
		return property;
	}

	//Compute the entity position property.
	//point1 - gdansk walesa
	//point2 - warszawa chopin				lon1		lat1	lon2		lat2
	//var position = computeCirclularFlight(18.467854, 54.379048, 20.967627, 48.167362);
//	var position = computeCirclularFlight(18.467854, 54.379048, 20.967627, 52.167362);
  //oblicz trase z nowej funkcji z gdanska do warszawy
  var position = generuj_trase_GDN_WAW(gdnwaw1.wylot,gdnwaw1.przylot);


	//Actually create the entity
	var entity = viewer.entities.add({

		//Set the entity availability to the same interval as the simulation time.
		availability : new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({
			start : start,
			stop : stop
		})]),

		//Use our computed positions
		position : position,

		//Automatically compute orientation based on position movement.
		orientation : new Cesium.VelocityOrientationProperty(position),

		//Load the Cesium plane model to represent the entity
		model : {
			uri : 'SampleData/models/CesiumAir/Cesium_Air.glb',
			minimumPixelSize : 64
		},

		//Show the path as a pink line sampled in 1 second increments.
		path : {
			resolution : 1,
			material : new Cesium.PolylineGlowMaterialProperty({
				glowPower : 0.1,
				color : Cesium.Color.YELLOW
			}),
			width : 10
		}
	});

  </script>
</body>
</html>
